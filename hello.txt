from flask import Flask, jsonify, render_template, request,redirect
from flask_cors import CORS
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from xgboost import XGBClassifier
import plotly.graph_objects as go
import logging
import traceback
from collections import defaultdict
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from pymongo import MongoClient
from bson import ObjectId
from datetime import datetime, timedelta
import re
from flask_mail import Mail, Message
import jwt
import os

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Create Flask application
app = Flask(__name__)
CORS(app)
# Configuration
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'your-secret-key-here')
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')

# Initialize extensions
mail = Mail(app)
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

# MongoDB setup
client = MongoClient(os.environ.get('MONGODB_URI', 'mongodb://localhost:27017/'))
db = client.mindscope_db
users_collection = db.users
sessions_collection = db.sessions
password_reset_collection = db.password_resets

# Dataset path
DATASET_PATH = "data/Depression Student Dataset.csv"

# User class
class User(UserMixin):
    def __init__(self, user_data):
        self.user_data = user_data
        self._id = user_data['_id']
    
    def get_id(self):
        return str(self._id)
        
    @property
    def is_active(self):
        return self.user_data.get('is_active', True)
    
    @property
    def is_authenticated(self):
        return True
    
    @property
    def is_anonymous(self):
        return False

@login_manager.user_loader
def load_user(user_id):
    user_data = users_collection.find_one({'_id': ObjectId(user_id)})
    if user_data:
        return User(user_data)
    return None

# ML Models dictionary
models = {
    'Logistic Regression': LogisticRegression(),
    'Decision Tree': DecisionTreeClassifier(),
    'Random Forest': RandomForestClassifier(),
    'Gradient Boosting': GradientBoostingClassifier(),
    'SVM': SVC(probability=True),
    'KNN': KNeighborsClassifier(),
    'Naive Bayes': GaussianNB(),
    'XGBoost': XGBClassifier()
}

class DataPreprocessor:
    def __init__(self):
        self.label_encoders = {}
        self.scaler = StandardScaler()
        self.categorical_columns = None
        self.numerical_columns = None
        self.target_encoder = LabelEncoder()
    
    def fit(self, df, y=None):
        self.categorical_columns = df.select_dtypes(include=['object', 'category']).columns
        self.numerical_columns = df.select_dtypes(include=['int64', 'float64']).columns
        
        for column in self.categorical_columns:
            self.label_encoders[column] = LabelEncoder()
            self.label_encoders[column].fit(df[column].astype(str))
        
        if len(self.numerical_columns) > 0:
            self.scaler.fit(df[self.numerical_columns])
        
        if y is not None:
            self.target_encoder.fit(y)
        
        return self
    
    def transform(self, df):
        df_transformed = df.copy()
        
        for column in self.categorical_columns:
            df_transformed[column] = self.label_encoders[column].transform(df_transformed[column].astype(str))
        
        if len(self.numerical_columns) > 0:
            df_transformed[self.numerical_columns] = self.scaler.transform(df_transformed[self.numerical_columns])
        
        return df_transformed
    
    def transform_target(self, y):
        return self.target_encoder.transform(y)
    
    def fit_transform(self, df, y=None):
        return self.fit(df, y).transform(df)
    
    def get_feature_names(self):
        return list(self.categorical_columns) + list(self.numerical_columns)
    
    def get_categorical_values(self, column):
        if column in self.categorical_columns:
            return self.label_encoders[column].classes_.tolist()
        return None

preprocessor = DataPreprocessor()

# Utility functions
def validate_password(password):
    """Validate password strength"""
    if len(password) < 8:
        return False, "Password must be at least 8 characters long"
    if not re.search("[a-z]", password):
        return False, "Password must contain lowercase letters"
    if not re.search("[A-Z]", password):
        return False, "Password must contain uppercase letters"
    if not re.search("[0-9]", password):
        return False, "Password must contain numbers"
    if not re.search("[^a-zA-Z0-9]", password):
        return False, "Password must contain special characters"
    return True, "Password is valid"

def send_verification_email(user_email, token):
    msg = Message('Verify Your MindScope Account',
                 sender='noreply@mindscope.com',
                 recipients=[user_email])
    verification_url = f"http://mindscope.com/verify/{token}"
    msg.body = f'Click the following link to verify your account: {verification_url}'
    mail.send(msg)

def generate_verification_token(user_id):
    return jwt.encode(
        {'user_id': str(user_id), 'exp': datetime.utcnow() + timedelta(days=1)},
        app.config['SECRET_KEY'],
        algorithm='HS256'
    )

def generate_auth_token(user_data):
    return jwt.encode(
        {
            'user_id': str(user_data['_id']),
            'exp': datetime.utcnow() + timedelta(days=1)
        },
        app.config['SECRET_KEY'],
        algorithm='HS256'
    )

# ML Helper functions
def evaluate_model(model, X_train, X_test, y_train, y_test):
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    
    return {
        'accuracy': accuracy_score(y_test, y_pred),
        'precision': precision_score(y_test, y_pred, pos_label=1),
        'recall': recall_score(y_test, y_pred, pos_label=1),
        'f1': f1_score(y_test, y_pred, pos_label=1)
    }

def get_best_split(model_name, X, y):
    split_ratios = [0.1, 0.2, 0.3, 0.4]
    results = []
    
    X_processed = preprocessor.fit_transform(X)
    y_encoded = preprocessor.transform_target(y)
    
    for split in split_ratios:
        scores = []
        for _ in range(5):
            X_train, X_test, y_train, y_test = train_test_split(X_processed, y_encoded, test_size=split, random_state=None)
            metrics = evaluate_model(models[model_name], X_train, X_test, y_train, y_test)
            scores.append(metrics)
        
        avg_metrics = {
            key: np.mean([score[key] for score in scores])
            for key in scores[0].keys()
        }
        results.append({
            'split': split,
            **avg_metrics
        })
    
    best_split = max(results, key=lambda x: x['f1'])
    
    return results, best_split

def compare_all_models(X, y):
    split_ratios = [0.1, 0.2, 0.3, 0.4]
    all_results = defaultdict(list)
    best_model_info = {
        'model': None,
        'split': None,
        'metrics': None,
        'avg_f1': -1
    }
    
    X_processed = preprocessor.fit_transform(X)
    y_encoded = preprocessor.transform_target(y)
    
    for model_name, model in models.items():
        model_f1_scores = []
        for split in split_ratios:
            scores = []
            for _ in range(5):
                X_train, X_test, y_train, y_test = train_test_split(
                    X_processed, y_encoded, test_size=split, random_state=None
                )
                metrics = evaluate_model(models[model_name], X_train, X_test, y_train, y_test)
                scores.append(metrics)
            
            avg_metrics = {
                key: np.mean([score[key] for score in scores])
                for key in scores[0].keys()
            }
            
            all_results[model_name].append({
                'split': split,
                **avg_metrics
            })
            model_f1_scores.append(avg_metrics['f1'])
        
        avg_f1 = np.mean(model_f1_scores)
        if avg_f1 > best_model_info['avg_f1']:
            best_split_idx = np.argmax(model_f1_scores)
            best_model_info = {
                'model': model_name,
                'split': split_ratios[best_split_idx],
                'metrics': all_results[model_name][best_split_idx],
                'avg_f1': avg_f1
            }
    
    return all_results, best_model_info

def generate_model_explanation(best_model_info):
    model_name = best_model_info['model']
    metrics = best_model_info['metrics']
    
    strengths = {
        'Logistic Regression': 'simple, interpretable, and efficient for linearly separable data',
        'Decision Tree': 'handles non-linear relationships and is easy to interpret',
        'Random Forest': 'reduces overfitting and handles complex relationships',
        'Gradient Boosting': 'typically provides high accuracy and handles imbalanced data well',
        'SVM': 'effective in high-dimensional spaces and handles non-linear relationships',
        'KNN': 'simple and effective for pattern recognition',
        'Naive Bayes': 'works well with high-dimensional data and is computationally efficient',
        'XGBoost': 'optimized implementation of gradient boosting with high performance'
    }
    
    explanation = f"""
    Based on comprehensive testing across multiple split ratios, the {model_name} emerged as the best model for this depression prediction task.
    
    Key Performance Metrics:
    - F1 Score: {metrics['f1']:.3f}
    - Accuracy: {metrics['accuracy']:.3f}
    - Precision: {metrics['precision']:.3f}
    - Recall: {metrics['recall']:.3f}
    
    Optimal Split Ratio: {best_model_info['split']}
    
    Why this model performs best:
    1. {strengths[model_name]}
    2. It achieves the best balance between precision and recall (F1 score)
    3. The model shows consistent performance across different train-test splits
    """
    return explanation

# Routes
@app.route('/')
def home():
    return render_template('index.html')
@app.route('/login', methods=['GET'])
def login_page():
    return render_template('login.html')

@app.route('/signup', methods=['GET'])
def signup_page():
    return render_template('signup.html')

@app.route('/auth/signup', methods=['POST'])
def signup():
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # Validate required fields
        required_fields = ['firstName', 'lastName', 'email', 'password', 'dateOfBirth', 'gender']
        missing_fields = [field for field in required_fields if not data.get(field)]
        if missing_fields:
            return jsonify({'error': f'Missing required fields: {", ".join(missing_fields)}'}), 400

        # Validate email format
        email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
        if not email_pattern.match(data['email']):
            return jsonify({'error': 'Invalid email format'}), 400

        # Validate password strength
        if len(data['password']) < 8:
            return jsonify({'error': 'Password must be at least 8 characters long'}), 400
        
        # Validate date format and range
        try:
            dob = datetime.strptime(data['dateOfBirth'], '%Y-%m-%d')
            if dob > datetime.now():
                return jsonify({'error': 'Date of birth cannot be in the future'}), 400
        except ValueError:
            return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD'}), 400

        # Validate gender (assuming specific allowed values)
        allowed_genders = ['male', 'female', 'other', 'prefer_not_to_say']
        if data['gender'].lower() not in allowed_genders:
            return jsonify({'error': 'Invalid gender value'}), 400

        # Sanitize inputs
        user_data = {
            'firstName': str(data['firstName']).strip()[:50],  # Limit length
            'lastName': str(data['lastName']).strip()[:50],
            'email': data['email'].lower().strip(),
            'password_hash': generate_password_hash(data['password'], method='pbkdf2:sha256:260000'),
            'dateOfBirth': dob,
            'gender': data['gender'].lower(),
            'created_at': datetime.utcnow(),
            'last_login': None,
            'failed_login_attempts': 0,
            'account_locked': False
        }

        # Create unique index on email if it doesn't exist
        users_collection.create_index('email', unique=True)

        try:
            result = users_collection.insert_one(user_data)
            return jsonify({
                'message': 'Signup successful',
                'userId': str(result.inserted_id)
            }), 201

        
        except Exception as e:
            logger.error(f"Database error during signup: {str(e)}")
            return jsonify({'error': 'An error occurred during signup'}), 500

    except Exception as e:
        logger.error(f"Unexpected error during signup: {str(e)}")
        return jsonify({'error': 'An unexpected error occurred'}), 500
            
@app.route('/auth/login', methods=['POST'])
def login():
    data = request.get_json()
    
    if not data.get('email') or not data.get('password'):
        return jsonify({'error': 'Missing email or password'}), 400

    user_data = users_collection.find_one({'email': data['email']})
    
    if not user_data:
        return jsonify({'error': 'Invalid email or password'}), 401
        
    if not user_data.get('is_verified', False):
        return jsonify({'error': 'Please verify your email before logging in'}), 401
    
    if check_password_hash(user_data['password_hash'], data['password']):
        user = User(user_data)
        login_user(user)
        
        # Update last login
        users_collection.update_one(
            {'_id': user_data['_id']},
            {
                '$set': {'last_login': datetime.utcnow()},
                '$push': {
                    'login_history': {
                        'timestamp': datetime.utcnow(),
                        'ip_address': request.remote_addr,
                        'user_agent': request.headers.get('User-Agent')
                    }
                }
            }
        )
        
        return jsonify({
            'message': 'Logged in successfully',
            'user': {
                'id': str(user_data['_id']),
                'firstName': user_data['firstName'],
                'lastName': user_data['lastName'],
                'email': user_data['email'],
                'profile_completed': user_data.get('profile_completed', False)
            },
            'token': generate_auth_token(user_data)
        })
    
    return jsonify({'error': 'Invalid email or password'}), 401

@app.route('/verify/<token>', methods=['GET'])
def verify_email(token):
    try:
        payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
        user_id = payload['user_id']
        
        result = users_collection.update_one(
            {'_id': ObjectId(user_id)},
            {'$set': {'is_verified': True}}
        )
        
        if result.modified_count:
            return jsonify({'message': 'Email verified successfully'}), 200
        return jsonify({'error': 'Verification failed'}), 400
    except jwt.ExpiredSignatureError:
        return jsonify({'error': 'Verification link expired'}), 400
    except jwt.InvalidTokenError:
        return jsonify({'error': 'Invalid verification link'}), 400

@app.route('/forgot-password', methods=['POST'])
def forgot_password():
    data = request.get_json()
    email = data.get('email')
    
    if not email:
        return jsonify({'error': 'Email is required'}), 400
        
    user = users_collection.find_one({'email': email})
    if not user:
        return jsonify({'message': 'If an account exists, a reset link will be sent'}), 200
        
    token = jwt.encode(
        {
            'user_id': str(user['_id']),
            'exp': datetime.utcnow() + timedelta(hours=1)
        },
        app.config['SECRET_KEY'],
        algorithm='HS256'
    )
    
    password_reset_collection.insert_one({
        'user_id': user['_id'],
        'token': token,
        'created_at': datetime.utcnow(),
        'used': False
    })
    
    msg = Message('Reset Your Password',
                 sender='noreply@mindscope.com',
                 recipients=[email])
    reset_url = f"http://yourdomain.com/reset-password/{token}"
    msg.body = f'Click the following link to reset your password: {reset_url}'
    mail.send(msg)
    
    return jsonify({'message': 'If an account exists, a reset link will be sent'}), 200

@app.route('/reset-password/<token>', methods=['POST'])
def reset_password(token):
    try:
        data = request.get_json()
        new_password = data.get('password')
        
        if not new_password:
            return jsonify({'error': 'New password is required'}), 400
            
        is_valid, password_message = validate_password(new_password)
        if not is_valid:
            return jsonify({'error': password_message}), 400
            
        payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
        user_id = payload['user_id']
        
        reset_record = password_reset_collection.find_one({
            'token': token,
            'used': False
        })
        
        if not reset_record:
            return jsonify({'error': 'Invalid or expired reset token'}), 400
            
        users_collection.update_one(
            {'_id': ObjectId(user_id)},
            {'$set': {'password_hash': generate_password_hash(new_password)}}
        )
        
        password_reset_collection.update_one(
            {'_id': reset_record['_id']},
            {'$set': {'used': True}}
        )
        
        return jsonify({'message': 'Password reset successfully'}), 200
    except jwt.ExpiredSignatureError:
        return jsonify({'error': 'Reset link expired'}), 400
    except jwt.InvalidTokenError:
        return jsonify({'error': 'Invalid reset link'}), 400

@app.route('/selection')
def model_selection():
    return render_template('model_selection.html', models=list(models.keys()))

@app.route('/performance/<model_name>')
def model_performance(model_name):
    df = pd.read_csv(DATASET_PATH)
    X = df.drop('Depression', axis=1)
    y = df['Depression']
    
    preprocessor.fit(X, y)
    feature_names = preprocessor.get_feature_names()
    categorical_values = {
        column: preprocessor.get_categorical_values(column)
        for column in preprocessor.categorical_columns
    }
    
    results, best_split = get_best_split(model_name, X, y)
    
    fig = go.Figure()
    metrics = ['accuracy', 'precision', 'recall', 'f1']
    
    for metric in metrics:
        fig.add_trace(go.Scatter(
            x=[r['split'] for r in results],
            y=[r[metric] for r in results],
            name=metric.capitalize(),
            mode='lines+markers'
        ))
    
    fig.update_layout(
        title=f'{model_name} Performance Across Different Split Ratios',
        xaxis_title='Test Split Ratio',
        yaxis_title='Score',
        yaxis_range=[0, 1]
    )
    
    explanation = f"""
    The best split ratio for {model_name} is {best_split['split']} with:
    - F1 Score: {best_split['f1']:.3f}
    - Accuracy: {best_split['accuracy']:.3f}
    - Precision: {best_split['precision']:.3f}
    - Recall: {best_split['recall']:.3f}
    """
    
    return render_template(
        'model_performance.html',
        model_name=model_name,
        plot=fig.to_html(full_html=False),
        best_split=best_split,
        explanation=explanation,
        feature_names=feature_names,
        categorical_values=categorical_values
    )

@app.route('/predict/<model_name>', methods=['POST'])
def predict(model_name):
    try:
        df = pd.read_csv(DATASET_PATH)
        X = df.drop('Depression', axis=1)
        y = df['Depression']
        
        form_data = request.form.to_dict()
        # logger.debug(f"Received form data: {form_data}")
        
        if not form_data:
            return jsonify({'success': False, 'error': 'No input data provided'}), 400
        
        if not hasattr(preprocessor, 'label_encoders') or not preprocessor.label_encoders:
            preprocessor.fit(X, y)
        
        ordered_features = [
            'Gender', 'Age', 'Academic Pressure', 'Study Satisfaction', 
            'Sleep Duration', 'Dietary Habits', 'Have you ever had suicidal thoughts ?',
            'Study Hours', 'Financial Stress', 'Family History of Mental Illness'
        ]
        
        ordered_data = {feature: form_data[feature] for feature in ordered_features}
        input_df = pd.DataFrame([ordered_data])
        
        try:
            input_processed = preprocessor.transform(input_df)
        except Exception as e:
            logger.error(f"Error in preprocessing: {str(e)}")
            return jsonify({'success': False, 'error': 'Invalid input data format'}), 400

        X_processed = preprocessor.transform(X)
        y_encoded = preprocessor.transform_target(y)
        
        X_train, X_test, y_train, y_test = train_test_split(
            X_processed, y_encoded, 
            test_size=0.2,
            random_state=42
        )

        model = models[model_name]
        model.fit(X_train, y_train)
        prediction_prob = model.predict_proba(input_processed)[0][1]
        
        return jsonify({
            'success': True,
            'depression_percentage': float(prediction_prob * 100),
            'prediction': "Yes" if prediction_prob >= 0.5 else "No"
        })

    except Exception as e:
        logger.error(f"Error in prediction: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/justification')
def model_justification():
    df = pd.read_csv(DATASET_PATH)
    X = df.drop('Depression', axis=1)
    y = df['Depression']
    
    all_results, best_model_info = compare_all_models(X, y)
    
    fig = go.Figure()
    for model_name, results in all_results.items():
        fig.add_trace(go.Bar(
            name=model_name,
            x=[f"Split {r['split']}" for r in results],
            y=[r['f1'] for r in results],
            text=[f"{r['f1']:.3f}" for r in results],
            textposition='auto',
        ))
    
    fig.update_layout(
        title='Model Performance Comparison Across Different Splits',
        xaxis_title='Test Split Ratio',
        yaxis_title='F1 Score',
        yaxis_range=[0, 1],
        barmode='group',
        height=600
    )
    
    explanation = generate_model_explanation(best_model_info)
    
    return render_template(
        'model_justification.html',
        plot=fig.to_html(full_html=False),
        best_model=best_model_info,
        explanation=explanation
    )

@app.route('/dataset')
def dataset_visualization():
    df = pd.read_csv(DATASET_PATH)
    
    dataset_info = {
        'num_rows': len(df),
        'num_features': len(df.columns),
        'numeric_features': df.select_dtypes(include=['int64', 'float64']).columns.tolist(),
        'categorical_features': df.select_dtypes(include=['object', 'category']).columns.tolist(),
        'missing_values': df.isnull().sum().to_dict()
    }
    
    feature_plots = {}
    for feature in df.columns:
        fig = go.Figure()
        if df[feature].dtype in ['int64', 'float64']:
            fig.add_trace(go.Histogram(x=df[feature], name="Distribution"))
            fig.add_trace(go.Box(x=df[feature], name="Box Plot"))
            fig.update_layout(title=f'Distribution and Box Plot of {feature}')
        else:
            value_counts = df[feature].value_counts()
            fig.add_trace(go.Bar(x=value_counts.index, y=value_counts.values))
            fig.update_layout(title=f'Distribution of {feature}')
        
        feature_plots[feature] = fig.to_html(full_html=False)
    
    correlation_matrix = df.select_dtypes(include=['int64', 'float64']).corr()
    correlation_plot = go.Figure(data=go.Heatmap(
        z=correlation_matrix,
        x=correlation_matrix.columns,
        y=correlation_matrix.columns,
        colorscale='RdBu',
        zmin=-1, zmax=1
    ))
    correlation_plot.update_layout(title='Feature Correlation Heatmap')
    
    return render_template(
        'dataset_visualization.html',
        dataset_info=dataset_info,
        feature_plots=feature_plots,
        correlation_plot=correlation_plot.to_html(full_html=False)
    )

@app.route('/update-profile', methods=['PUT'])
@login_required
def update_profile():
    data = request.get_json()
    allowed_fields = ['firstName', 'lastName', 'phone', 'dateOfBirth', 'gender', 'preferences']
    
    update_data = {k: v for k, v in data.items() if k in allowed_fields}
    
    if 'dateOfBirth' in update_data:
        try:
            update_data['dateOfBirth'] = datetime.strptime(update_data['dateOfBirth'], '%Y-%m-%d')
        except ValueError:
            return jsonify({'error': 'Invalid date format'}), 400
    
    try:
        users_collection.update_one(
            {'_id': ObjectId(current_user.get_id())},
            {
                '$set': {
                    **update_data,
                    'profile_completed': True,
                    'updated_at': datetime.utcnow()
                }
            }
        )
        return jsonify({'message': 'Profile updated successfully'}), 200
    except Exception as e:
        logger.error(f"Error updating profile: {str(e)}")
        return jsonify({'error': 'Error updating profile'}), 500

@app.route('/explore')
def explore():
    return render_template('explore.html')

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500

def create_indexes():
    users_collection.create_index('email', unique=True)
    users_collection.create_index('phone')
    password_reset_collection.create_index('created_at', expireAfterSeconds=3600)
    db.activity_logs.create_index('timestamp')
    db.activity_logs.create_index('user_id')

@app.route('/change-password', methods=['POST'])
@login_required
def change_password():
    data = request.get_json()
    current_password = data.get('currentPassword')
    new_password = data.get('newPassword')
    
    if not current_password or not new_password:
        return jsonify({'error': 'Both current and new passwords are required'}), 400
    
    user_data = users_collection.find_one({'_id': ObjectId(current_user.get_id())})
    
    if not check_password_hash(user_data['password_hash'], current_password):
        return jsonify({'error': 'Current password is incorrect'}), 401
    
    is_valid, password_message = validate_password(new_password)
    if not is_valid:
        return jsonify({'error': password_message}), 400
    
    try:
        users_collection.update_one(
            {'_id': ObjectId(current_user.get_id())},
            {
                '$set': {
                    'password_hash': generate_password_hash(new_password),
                    'password_updated_at': datetime.utcnow()
                }
            }
        )
        return jsonify({'message': 'Password updated successfully'}), 200
    except Exception as e:
        logger.error(f"Error changing password: {str(e)}")
        return jsonify({'error': 'Error updating password'}), 500

@app.route('/export-data', methods=['GET'])
@login_required
def export_user_data():
    try:
        user_data = users_collection.find_one({'_id': ObjectId(current_user.get_id())})
        sessions = list(sessions_collection.find({'user_id': ObjectId(current_user.get_id())}))
        
        # Remove sensitive information
        user_data.pop('password_hash', None)
        user_data['_id'] = str(user_data['_id'])
        
        for session in sessions:
            session['_id'] = str(session['_id'])
            session['user_id'] = str(session['user_id'])
        
        export_data = {
            'user_info': user_data,
            'sessions': sessions,
            'exported_at': datetime.utcnow().isoformat()
        }
        
        return jsonify(export_data), 200
    except Exception as e:
        logger.error(f"Error exporting user data: {str(e)}")
        return jsonify({'error': 'Error exporting data'}), 500

@app.route('/analytics/trends', methods=['GET'])
@login_required
def get_trends():
    try:
        user_sessions = list(sessions_collection.find({
            'user_id': ObjectId(current_user.get_id()),
            'timestamp': {'$gte': datetime.utcnow() - timedelta(days=30)}
        }).sort('timestamp', 1))
        
        if not user_sessions:
            return jsonify({'message': 'No data available for analysis'}), 200
        
        # Process session data for trends
        daily_scores = defaultdict(list)
        for session in user_sessions:
            date = session['timestamp'].strftime('%Y-%m-%d')
            daily_scores[date].append(session.get('depression_score', 0))
        
        trends = {
            'daily_averages': {
                date: sum(scores) / len(scores)
                for date, scores in daily_scores.items()
            },
            'overall_trend': calculate_trend([
                sum(scores) / len(scores)
                for scores in daily_scores.values()
            ]),
            'recommendations': generate_recommendations(daily_scores)
        }
        
        return jsonify(trends), 200
    except Exception as e:
        logger.error(f"Error calculating trends: {str(e)}")
        return jsonify({'error': 'Error calculating trends'}), 500

def calculate_trend(values):
    if not values:
        return 'neutral'
    
    # Simple linear regression
    x = list(range(len(values)))
    y = values
    
    slope = np.polyfit(x, y, 1)[0]
    
    if slope > 0.1:
        return 'improving'
    elif slope < -0.1:
        return 'worsening'
    else:
        return 'stable'

def generate_recommendations(daily_scores):
    recommendations = []
    
    # Analyze patterns and generate recommendations
    scores_list = [score for scores in daily_scores.values() for score in scores]
    avg_score = sum(scores_list) / len(scores_list) if scores_list else 0
    
    if avg_score > 0.7:
        recommendations.append({
            'type': 'urgent',
            'message': 'Consider scheduling an appointment with a mental health professional',
            'action': 'contact_professional'
        })
    elif avg_score > 0.5:
        recommendations.append({
            'type': 'warning',
            'message': 'Your scores indicate elevated stress levels. Try incorporating relaxation techniques.',
            'action': 'stress_management'
        })
    
    # Check for consistency in reporting
    if len(daily_scores) < 7:
        recommendations.append({
            'type': 'info',
            'message': 'Regular check-ins help us provide better insights. Try to log your mood daily.',
            'action': 'daily_checkin'
        })
    
    return recommendations

@app.route('/session/start', methods=['POST'])
@login_required
def start_session():
    try:
        session_data = {
            'user_id': ObjectId(current_user.get_id()),
            'start_time': datetime.utcnow(),
            'status': 'in_progress',
            'responses': []
        }
        
        result = sessions_collection.insert_one(session_data)
        
        return jsonify({
            'session_id': str(result.inserted_id),
            'message': 'Session started successfully'
        }), 201
    except Exception as e:
        logger.error(f"Error starting session: {str(e)}")
        return jsonify({'error': 'Error starting session'}), 500

@app.route('/session/<session_id>/answer', methods=['POST'])
@login_required
def submit_answer(session_id):
    try:
        data = request.get_json()
        answer = data.get('answer')
        question_id = data.get('question_id')
        
        if not answer or not question_id:
            return jsonify({'error': 'Answer and question ID are required'}), 400
        
        sessions_collection.update_one(
            {
                '_id': ObjectId(session_id),
                'user_id': ObjectId(current_user.get_id())
            },
            {
                '$push': {
                    'responses': {
                        'question_id': question_id,
                        'answer': answer,
                        'timestamp': datetime.utcnow()
                    }
                }
            }
        )
        
        return jsonify({'message': 'Answer recorded successfully'}), 200
    except Exception as e:
        logger.error(f"Error recording answer: {str(e)}")
        return jsonify({'error': 'Error recording answer'}), 500

@app.route('/session/<session_id>/end', methods=['POST'])
@login_required
def end_session(session_id):
    try:
        session = sessions_collection.find_one({
            '_id': ObjectId(session_id),
            'user_id': ObjectId(current_user.get_id())
        })
        
        if not session:
            return jsonify({'error': 'Session not found'}), 404
        
        # Calculate session scores and insights
        responses = session.get('responses', [])
        depression_score = calculate_depression_score(responses)
        insights = generate_session_insights(responses)
        
        sessions_collection.update_one(
            {'_id': ObjectId(session_id)},
            {
                '$set': {
                    'end_time': datetime.utcnow(),
                    'status': 'completed',
                    'depression_score': depression_score,
                    'insights': insights
                }
            }
        )
        
        return jsonify({
            'message': 'Session completed successfully',
            'depression_score': depression_score,
            'insights': insights
        }), 200
    except Exception as e:
        logger.error(f"Error ending session: {str(e)}")
        return jsonify({'error': 'Error ending session'}), 500

def calculate_depression_score(responses):
    # Implement scoring algorithm based on responses
    # This is a simplified example
    score = 0
    total_questions = len(responses)
    
    if total_questions == 0:
        return 0
    
    for response in responses:
        answer = response['answer']
        if isinstance(answer, (int, float)):
            score += answer
        elif isinstance(answer, str):
            # Convert text responses to numerical scores based on sentiment
            # This would need a more sophisticated implementation
            pass
    
    return score / total_questions

def generate_session_insights(responses):
    # Analyze responses to generate insights
    insights = {
        'summary': '',
        'risk_factors': [],
        'protective_factors': [],
        'recommendations': []
    }
    return insights

@app.route('/resources')
def get_resources():
    # Return mental health resources and information
    resources = {
        'emergency': [
            {
                'name': 'National Suicide Prevention Lifeline',
                'phone': '1-800-273-8255',
                'available': '24/7'
            },
            {
                'name': 'Crisis Text Line',
                'phone': 'Text HOME to 741741',
                'available': '24/7'
            }
        ],
        'therapy': [
            {
                'type': 'Online Therapy',
                'description': 'Professional counseling services available online',
                'link': 'https://www.example.com/therapy'
            }
        ],
        'self_help': [
            {
                'title': 'Meditation Guide',
                'description': 'Learn meditation techniques for stress relief',
                'link': 'https://www.example.com/meditation'
            },
            {
                'title': 'Sleep Hygiene',
                'description': 'Tips for better sleep habits',
                'link': 'https://www.example.com/sleep'
            }
        ]
    }
    
    return jsonify(resources), 200
if __name__ == '__main__':
    try:
        df = pd.read_csv(DATASET_PATH)
        logger.info(f"Successfully loaded dataset with {len(df)} samples and {len(df.columns)} features")
        
        X = df.drop('Depression', axis=1)
        y = df['Depression']
        preprocessor.fit(X, y)
        logger.info("Successfully initialized preprocessor")
        
        create_indexes()
        app.run(debug=True)
    except Exception as e:
        logger.error(f"error")